package main

import (
	"fmt"
	"github.com/a-peyrard/godi/slices"
	"os"
	stdslices "slices"
	"strings"
	"text/template"
)

const registryTemplate = `// Code generated by go generate; DO NOT EDIT!

package {{.PackageName}}

import (
	"{{.DIImportPath}}"
{{range .Imports}}	"{{.}}"
{{end}})

func ({{.StructName}}) Register(resolver *godi.Resolver) {
{{range .Providers}}{{if .Options}}	resolver.MustRegister(
		{{.FnName}},
{{range .Options}}		{{.}},
{{end}}	)
{{else}}	resolver.MustRegister({{.FnName}})
{{end}}{{end}}}
`

type ProviderForTemplate struct {
	FnName  string
	Options []string
}

func toProviderForTemplate(p ProviderDefinition) ProviderForTemplate {
	var options []string
	if p.Named != "" {
		options = append(options, fmt.Sprintf("godi.Named(\"%s\")", p.Named))
	}
	if p.Priority != 0 {
		options = append(options, fmt.Sprintf("godi.Priority(%d)", p.Priority))
	}

	var dependencies []string
	for _, dep := range p.Dependencies {
		if dep != "" {
			dependencies = append(dependencies, fmt.Sprintf("di.Inject.Named(\"%s\")", dep))
		} else {
			dependencies = append(dependencies, "di.Inject.Auto()")
		}
	}
	if len(dependencies) > 0 {
		depStr := "godi.Dependencies(\n\t\t\t" + strings.Join(dependencies, ",\n\t\t\t") + ",\n\t\t)"
		options = append(options, depStr)
	}

	return ProviderForTemplate{
		FnName:  p.FnName,
		Options: options,
	}
}

func generateCode(outputPath string, registryDef *RegistryDefinition, providers []ProviderDefinition) error {
	tmpl := template.Must(template.New("registry").Parse(registryTemplate))

	// Use a map to track unique imports instead of external set package
	importMap := make(map[string]bool)
	for _, p := range providers {
		importMap[p.ImportPath] = true
	}

	var importsList []string
	for imp := range importMap {
		importsList = append(importsList, imp)
	}
	stdslices.Sort(importsList)

	// gather the data for the template
	data := map[string]interface{}{
		"PackageName":  registryDef.PackageName,
		"StructName":   registryDef.StructName,
		"DIImportPath": "github.com/a-peyrard/godi",
		"Imports":      importsList,
		"Providers":    slices.Map(providers, toProviderForTemplate),
	}

	file, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	//goland:noinspection GoUnhandledErrorResult
	defer file.Close()

	return tmpl.Execute(file, data)
}
