package main

import (
	"fmt"
	"github.com/a-peyrard/godi/set"
	"github.com/a-peyrard/godi/slices"
	"os"
	"path/filepath"
	stdslices "slices"
	"strconv"
	"strings"
	"text/template"
)

const (
	diImportPath           = "github.com/a-peyrard/godi"
	configLoaderImportPath = "github.com/a-peyrard/godi/config"
)

const registryTemplate = `// Code generated by go generate; DO NOT EDIT!

package {{.PackageName}}

import (
{{range .Imports}}	{{.}}
{{end}})

func ({{.StructName}}) Register(resolver *godi.Resolver) {
{{range .Providers}}{{if .Options}}	resolver.MustRegister(
		{{.FnName}},
{{range .Options}}		{{.}},
{{end}}	)
{{else}}	resolver.MustRegister({{.FnName}})
{{end}}{{end}}}
`

type ProviderForTemplate struct {
	FnName  string
	Options []string
}

func toProviderForTemplate(p ProviderDefinition, importWithAlias map[string]string) ProviderForTemplate {
	var options []string
	if p.Named != "" {
		options = append(options, fmt.Sprintf("godi.Named(\"%s\")", p.Named))
	}
	if p.Priority != 0 {
		options = append(options, fmt.Sprintf("godi.Priority(%d)", p.Priority))
	}
	if p.Conditions != nil && len(p.Conditions) > 0 {
		for _, condition := range p.Conditions {
			options = append(options, whenAnnotationToOption(condition))
		}
	}

	var dependencies []string
	for _, dep := range p.Dependencies {
		multiple, found := dep.Multiple()
		if found && multiple {
			dependencies = append(dependencies, "godi.Inject.Multiple()")
			continue
		}

		named, found := dep.Named()
		if found {
			dependencies = append(dependencies, fmt.Sprintf("godi.Inject.Named(\"%s\")", named))
			continue
		}
		dependencies = append(dependencies, "godi.Inject.Auto()")
	}
	options = appendDependenciesToOptions(options, dependencies)

	return ProviderForTemplate{
		FnName:  generateFQN(p.ImportPath, p.FnName, importWithAlias),
		Options: options,
	}
}

func whenAnnotationToOption(condition WhenAnnotation) string {
	return fmt.Sprintf("godi.When(\"%s\").%s(\"%s\")", condition.named, toOperator(condition.operator), condition.value)
}

func toOperator(operator string) any {
	switch operator {
	case "equals":
		return "Equals"
	case "not_equals":
		return "NotEquals"
	}
	return fmt.Sprintf("UnknownOperator(%q)", operator)
}

func appendDependenciesToOptions(options []string, dependencies []string) []string {
	if len(dependencies) > 0 {
		depStr := "godi.Dependencies(\n\t\t\t" + strings.Join(dependencies, ",\n\t\t\t") + ",\n\t\t)"
		options = append(options, depStr)
	}
	return options
}

func configToProvidersForTemplate(config ConfigDefinition, importWithAlias map[string]string) []ProviderForTemplate {
	var (
		providers               []ProviderForTemplate
		configLoaderImportAlias = importWithAlias[configLoaderImportPath]
	)

	// first the prefix as a static string provider
	prefixName := "EnvPrefix4" + config.TypeName
	configStructFQN := generateFQN(config.ImportPath, config.TypeName, importWithAlias)

	providers = append(providers, ProviderForTemplate{
		FnName:  fmt.Sprintf("godi.ToStaticProvider(\"%s\")", config.Annotation.Prefix()),
		Options: []string{fmt.Sprintf("godi.Named(\"%s\")", prefixName)},
	})

	// now we should load the config struct itself, with config.Load which is actually a factory method
	options := []string{
		fmt.Sprintf("godi.Named(\"%s\")", config.TypeName),
	}
	options = appendDependenciesToOptions(options, []string{
		fmt.Sprintf("godi.Inject.Named(\"%s\")", prefixName),
	})
	providers = append(providers, ProviderForTemplate{
		FnName:  fmt.Sprintf("func(envPrefix string) (*%s, error) {\n\t\t\treturn %s.Load[%s](%s.WithEnvPrefix(envPrefix))\n\t\t}", configStructFQN, configLoaderImportAlias, configStructFQN, configLoaderImportAlias),
		Options: options,
	})

	// finally, we will add a dynamic provider which will allow to resolve the config fields
	providers = append(
		providers,
		ProviderForTemplate{
			FnName: fmt.Sprintf("&godi.ConfigDynamicProvider[%s]{}", configStructFQN),
		},
	)

	return providers
}

func generateCode(outputPath string, registryDef *RegistryDefinition, providers []ProviderDefinition, configs []ConfigDefinition) error {
	tmpl := template.Must(template.New("registry").Parse(registryTemplate))

	imports := []string{diImportPath}
	for _, p := range providers {
		imports = append(imports, p.ImportPath)
	}
	if len(configs) > 0 {
		imports = append(imports, configLoaderImportPath)
		for _, config := range configs {
			if config.ImportPath != "" {
				imports = append(imports, config.ImportPath)
			}
		}
	}
	imports = set.NewFromSlice(imports).ToSlice()
	stdslices.Sort(imports)

	importWithAlias := map[string]string{}
	aliases := set.New[string]()
	for _, imp := range imports {
		alias := findSuitableAlias(imp, aliases)
		importWithAlias[imp] = alias
		aliases.Add(alias)
	}

	var importsForTemplate []string
	for _, imp := range imports {
		alias := importWithAlias[imp]
		if alias == "" || alias == filepath.Base(imp) {
			// don't use redundant aliases
			importsForTemplate = append(importsForTemplate, fmt.Sprintf("\"%s\"", imp))
		} else {
			importsForTemplate = append(importsForTemplate, fmt.Sprintf("%s \"%s\"", importWithAlias[imp], imp))
		}
	}
	stdslices.Sort(importsForTemplate)

	// gather the data for the template
	var providerTemplates []ProviderForTemplate
	providerTemplates = append(providerTemplates, slices.Map(providers, func(p ProviderDefinition) ProviderForTemplate {
		return toProviderForTemplate(p, importWithAlias)
	})...)
	providerTemplates = append(providerTemplates, slices.FlatMap(configs, func(config ConfigDefinition) []ProviderForTemplate {
		return configToProvidersForTemplate(config, importWithAlias)
	})...)

	data := map[string]interface{}{
		"PackageName":  registryDef.PackageName,
		"StructName":   registryDef.StructName,
		"DIImportPath": "github.com/a-peyrard/godi",
		"Imports":      importsForTemplate,
		"Providers":    providerTemplates,
	}

	file, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	//goland:noinspection GoUnhandledErrorResult
	defer file.Close()

	return tmpl.Execute(file, data)
}

func findSuitableAlias(importPath string, aliases set.Set[string]) string {
	tokens := strings.Split(importPath, "/")
	candidate := tokens[len(tokens)-1]

	if aliases.DoesNotContain(candidate) {
		return candidate
	}

	for i := 0; i < len(tokens)-1; i++ {
		token := tokens[len(tokens)-2-i]
		candidate = string(token[0]) + candidate
		if aliases.DoesNotContain(candidate) {
			return candidate
		}
	}

	for i := 0; i < 100; i++ { // can we really have more than 100 collisions?
		indexedCandidate := candidate + strconv.Itoa(i)
		if aliases.DoesNotContain(indexedCandidate) {
			return indexedCandidate
		}
	}

	// if this happens, I should probably play the cal lottery
	panic("didn't find a suitable alias for " + importPath)
}

func generateFQN(importPath string, typeName string, importWithAlias map[string]string) string {
	if importPath == "" {
		return typeName
	}
	if strings.HasPrefix(typeName, "*") {
		return fmt.Sprintf("*%s.%s", importWithAlias[importPath], typeName[1:])
	}
	return fmt.Sprintf("%s.%s", importWithAlias[importPath], typeName)
}
